"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var url = __importStar(require("url"));
var parser_1 = require("./util/parser");
var signature_1 = require("./util/signature");
var webhooks_1 = require("./util/webhooks");
var errors_1 = require("./errors");
var Webhooks = /** @class */ (function () {
    function Webhooks(_a) {
        var publicKey = _a.publicKey, secretKey = _a.secretKey;
        var _this = this;
        /**
         * Injects the webhook public key for authentication
         * @param header X-FormSG-Signature header
         * @param uri The endpoint that FormSG is POSTing to
         * @returns true if the header is verified
         * @throws {WebhookAuthenticateError} If the signature or uri cannot be verified
         */
        this.authenticate = function (header, uri) {
            // Parse the header
            var signatureHeader = (0, parser_1.parseSignatureHeader)(header);
            var signature = signatureHeader.v1, epoch = signatureHeader.t, submissionId = signatureHeader.s, formId = signatureHeader.f;
            // Verify signature authenticity
            if (!(0, webhooks_1.isSignatureHeaderValid)(uri, signatureHeader, _this.publicKey)) {
                throw new errors_1.WebhookAuthenticateError("Signature could not be verified for uri=".concat(uri, " submissionId=").concat(submissionId, " formId=").concat(formId, " epoch=").concat(epoch, " signature=").concat(signature));
            }
            // Verify epoch recency
            if ((0, webhooks_1.hasEpochExpired)(epoch)) {
                throw new errors_1.WebhookAuthenticateError("Signature is not recent for uri=".concat(uri, " submissionId=").concat(submissionId, " formId=").concat(formId, " epoch=").concat(epoch, " signature=").concat(signature));
            }
            // All checks pass.
            return true;
        };
        /**
         * Generates a signature based on the URI, submission ID and epoch timestamp.
         * @param params The parameters needed to generate the signature
         * @param params.uri Full URL of the request
         * @param params.submissionId Submission Mongo ObjectId saved to the database
         * @param params.epoch Number of milliseconds since Jan 1, 1970
         * @returns the generated signature
         * @throws {MissingSecretKeyError} if a secret key is not provided when instantiating this class
         * @throws {TypeError} if any parameters are undefined
         */
        this.generateSignature = function (_a) {
            var uri = _a.uri, submissionId = _a.submissionId, formId = _a.formId, epoch = _a.epoch;
            if (!_this.secretKey) {
                throw new errors_1.MissingSecretKeyError();
            }
            if (!submissionId || !uri || !formId || !epoch) {
                throw new TypeError('submissionId, uri, formId, or epoch must be provided to generate a webhook signature');
            }
            var baseString = "".concat(url.parse(uri).href, ".").concat(submissionId, ".").concat(formId, ".").concat(epoch);
            return (0, signature_1.sign)(baseString, _this.secretKey);
        };
        /**
         * Constructs the `X-FormSG-Signature` header
         * @param params The parameters needed to construct the header
         * @param params.epoch Epoch timestamp
         * @param params.submissionId Mongo ObjectId
         * @param params.formId Mongo ObjectId
         * @param params.signature A signature generated by the generateSignature() function
         * @returns The `X-FormSG-Signature` header
         * @throws {Error} if a secret key is not provided when instantiating this class
         */
        this.constructHeader = function (_a) {
            var epoch = _a.epoch, submissionId = _a.submissionId, formId = _a.formId, signature = _a.signature;
            if (!_this.secretKey) {
                throw new errors_1.MissingSecretKeyError();
            }
            return "t=".concat(epoch, ",s=").concat(submissionId, ",f=").concat(formId, ",v1=").concat(signature);
        };
        this.publicKey = publicKey;
        this.secretKey = secretKey;
    }
    return Webhooks;
}());
exports.default = Webhooks;
