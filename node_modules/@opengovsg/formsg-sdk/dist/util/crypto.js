"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertEncryptedAttachmentToFileContent = exports.areAttachmentFieldIdsValid = exports.verifySignedMessage = exports.decryptContent = exports.encryptMessage = exports.generateKeypair = void 0;
var tweetnacl_1 = __importDefault(require("tweetnacl"));
var tweetnacl_util_1 = require("tweetnacl-util");
/**
 * Helper method to generate a new keypair for encryption.
 * @returns The generated keypair.
 */
var generateKeypair = function () {
    var kp = tweetnacl_1.default.box.keyPair();
    return {
        publicKey: (0, tweetnacl_util_1.encodeBase64)(kp.publicKey),
        secretKey: (0, tweetnacl_util_1.encodeBase64)(kp.secretKey),
    };
};
exports.generateKeypair = generateKeypair;
/**
 * Helper function to encrypt input with a unique keypair for each submission.
 * @param msg The message to encrypt
 * @param theirPublicKey The base-64 encoded public key
 * @returns The encrypted basestring
 * @throws error if any of the encrypt methods fail
 */
var encryptMessage = function (msg, theirPublicKey) {
    var submissionKeypair = (0, exports.generateKeypair)();
    var nonce = tweetnacl_1.default.randomBytes(24);
    var encrypted = (0, tweetnacl_util_1.encodeBase64)(tweetnacl_1.default.box(msg, nonce, (0, tweetnacl_util_1.decodeBase64)(theirPublicKey), (0, tweetnacl_util_1.decodeBase64)(submissionKeypair.secretKey)));
    return "".concat(submissionKeypair.publicKey, ";").concat((0, tweetnacl_util_1.encodeBase64)(nonce), ":").concat(encrypted);
};
exports.encryptMessage = encryptMessage;
/**
 * Helper method to decrypt an encrypted submission.
 * @param formPrivateKey base64
 * @param encryptedContent encrypted string encoded in base64
 * @return The decrypted content, or null if decryption failed.
 */
var decryptContent = function (formPrivateKey, encryptedContent) {
    try {
        var _a = encryptedContent.split(';'), submissionPublicKey = _a[0], nonceEncrypted = _a[1];
        var _b = nonceEncrypted.split(':').map(tweetnacl_util_1.decodeBase64), nonce = _b[0], encrypted = _b[1];
        return tweetnacl_1.default.box.open(encrypted, nonce, (0, tweetnacl_util_1.decodeBase64)(submissionPublicKey), (0, tweetnacl_util_1.decodeBase64)(formPrivateKey));
    }
    catch (err) {
        return null;
    }
};
exports.decryptContent = decryptContent;
/**
 * Helper method to verify a signed message.
 * @param msg the message to verify
 * @param publicKey the public key to authenticate the signed message with
 * @returns the signed message if successful, else an error will be thrown
 * @throws {Error} if the message cannot be verified
 */
var verifySignedMessage = function (msg, publicKey) {
    var openedMessage = tweetnacl_1.default.sign.open(msg, (0, tweetnacl_util_1.decodeBase64)(publicKey));
    if (!openedMessage)
        throw new Error('Failed to open signed message with given public key');
    return JSON.parse((0, tweetnacl_util_1.encodeUTF8)(openedMessage));
};
exports.verifySignedMessage = verifySignedMessage;
/**
 * Helper method to check if all the field IDs given are within the filenames
 * @param fieldIds the list of fieldIds to check
 * @param filenames the filenames that should contain the fields
 * @returns boolean indicating whether the fields are valid
 */
var areAttachmentFieldIdsValid = function (fieldIds, filenames) {
    return fieldIds.every(function (fieldId) { return filenames[fieldId]; });
};
exports.areAttachmentFieldIdsValid = areAttachmentFieldIdsValid;
/**
 * Converts an encrypted attachment to encrypted file content
 * @param encryptedAttachment The encrypted attachment
 * @returns EncryptedFileContent The encrypted file content
 */
var convertEncryptedAttachmentToFileContent = function (encryptedAttachment) { return ({
    submissionPublicKey: encryptedAttachment.encryptedFile.submissionPublicKey,
    nonce: encryptedAttachment.encryptedFile.nonce,
    binary: (0, tweetnacl_util_1.decodeBase64)(encryptedAttachment.encryptedFile.binary),
}); };
exports.convertEncryptedAttachmentToFileContent = convertEncryptedAttachmentToFileContent;
